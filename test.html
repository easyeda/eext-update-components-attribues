<!doctype html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>MQTT ç½‘ç»œå¯¹è®²æœº</title>
		<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				padding: 20px;
				background: #f4f4f4;
			}
			.container {
				max-width: 600px;
				margin: auto;
				background: white;
				padding: 20px;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}
			input,
			button {
				padding: 10px;
				margin: 10px 0;
				width: 100%;
				box-sizing: border-box;
			}
			button {
				background: #007bff;
				color: white;
				border: none;
				cursor: pointer;
			}
			button:disabled {
				background: #ccc;
				cursor: not-allowed;
			}
			.status {
				padding: 10px;
				margin: 10px 0;
				border-radius: 4px;
				background: #eee;
			}
			.log {
				height: 150px;
				overflow-y: scroll;
				background: #f9f9f9;
				padding: 10px;
				border: 1px solid #ddd;
				font-size: 0.9em;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h2>ğŸ™ï¸ MQTT ç½‘ç»œå¯¹è®²æœº</h2>

			<label>MQTT Broker åœ°å€:</label>
			<input type="text" id="brokerHost" placeholder="ä¾‹å¦‚ï¼š192.168.1.100 æˆ– broker.example.com" />

			<button id="connectBtn">è¿æ¥</button>
			<button id="startTalkBtn" disabled>æŒ‰ä½è¯´è¯</button>

			<div class="status" id="status">çŠ¶æ€ï¼šæœªè¿æ¥</div>
			<div class="log" id="log"></div>
		</div>

		<script>
			let client = null;
			let isTalking = false;
			let mediaRecorder = null;
			let audioChunks = [];
			const topic = 'voice/broadcast';

			const statusEl = document.getElementById('status');
			const logEl = document.getElementById('log');
			const connectBtn = document.getElementById('connectBtn');
			const startTalkBtn = document.getElementById('startTalkBtn');
			const brokerHostInput = document.getElementById('brokerHost');

			function log(msg) {
				const entry = document.createElement('div');
				entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
				logEl.appendChild(entry);
				logEl.scrollTop = logEl.scrollHeight;
			}

			// è¿æ¥ MQTT
			connectBtn.addEventListener('click', () => {
				const host = brokerHostInput.value.trim();
				if (!host) {
					alert('è¯·è¾“å…¥ MQTT Broker åœ°å€');
					return;
				}

				const wsUrl = `ws://${host}:8083/mqtt`;
				statusEl.textContent = `æ­£åœ¨è¿æ¥ ${wsUrl}...`;
				log(`è¿æ¥åˆ° ${wsUrl}`);

				client = mqtt.connect(wsUrl, {
					protocolVersion: 4, // MQTT 3.1.1
					clean: true,
					reconnectPeriod: 3000,
				});

				client.on('connect', () => {
					statusEl.textContent = 'å·²è¿æ¥ï¼è®¢é˜…ä¸­...';
					log('âœ… è¿æ¥æˆåŠŸ');
					client.subscribe(topic, (err) => {
						if (!err) {
							log(`ğŸ‘‚ å·²è®¢é˜…ä¸»é¢˜: ${topic}`);
							startTalkBtn.disabled = false;
						} else {
							log(`âŒ è®¢é˜…å¤±è´¥: ${err}`);
						}
					});
				});

				client.on('message', (receivedTopic, payload) => {
					if (receivedTopic === topic) {
						try {
							const dataStr = new TextDecoder().decode(payload);
							const { audioBase64 } = JSON.parse(dataStr);
							playAudio(audioBase64);
							log('ğŸ”Š æ”¶åˆ°å¹¿æ’­è¯­éŸ³');
						} catch (e) {
							log('âš ï¸ è§£æéŸ³é¢‘æ¶ˆæ¯å¤±è´¥');
						}
					}
				});

				client.on('error', (err) => {
					log(`âŒ è¿æ¥é”™è¯¯: ${err.message}`);
					statusEl.textContent = 'è¿æ¥å¤±è´¥';
				});

				client.on('close', () => {
					log('ğŸ”Œ è¿æ¥å·²å…³é—­');
					statusEl.textContent = 'è¿æ¥å·²å…³é—­';
					startTalkBtn.disabled = true;
				});
			});

			// æŒ‰ä½è¯´è¯
			startTalkBtn.addEventListener('mousedown', async () => {
				if (isTalking) return;
				isTalking = true;
				startTalkBtn.textContent = 'æ¾å¼€ç»“æŸ';

				try {
					const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
					mediaRecorder = new MediaRecorder(stream);

					audioChunks = [];
					mediaRecorder.ondataavailable = (event) => {
						audioChunks.push(event.data);
					};

					mediaRecorder.onstop = () => {
						const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
						const reader = new FileReader();
						reader.onload = () => {
							const base64Audio = reader.result.split(',')[1]; // å»æ‰ data:audio/webm;base64,
							// å‘å¸ƒéŸ³é¢‘
							if (client && client.connected) {
								client.publish(
									topic,
									JSON.stringify({
										audioBase64: base64Audio,
										timestamp: Date.now(),
									}),
								);
								log('ğŸ“¤ å¹¿æ’­è¯­éŸ³å·²å‘é€');
							}
						};
						reader.readAsDataURL(audioBlob);
					};

					mediaRecorder.start();
					log('ğŸ¤ å¼€å§‹å½•éŸ³...');
				} catch (err) {
					log(`ğŸš« æ— æ³•è®¿é—®éº¦å…‹é£: ${err.message}`);
					isTalking = false;
					startTalkBtn.textContent = 'æŒ‰ä½è¯´è¯';
				}
			});

			startTalkBtn.addEventListener('mouseup', () => {
				if (!isTalking) return;
				isTalking = false;
				startTalkBtn.textContent = 'æŒ‰ä½è¯´è¯';

				if (mediaRecorder && mediaRecorder.state === 'recording') {
					mediaRecorder.stop();
					// åœæ­¢æ‰€æœ‰è½¨é“
					mediaRecorder.stream.getTracks().forEach((track) => track.stop());
				}
			});

			startTalkBtn.addEventListener('mouseout', () => {
				if (startTalkBtn === document.activeElement) {
					startTalkBtn.blur(); // é˜²æ­¢é¼ æ ‡ç§»å‡ºæ—¶ä»è§¦å‘
				}
			});

			// æ’­æ”¾éŸ³é¢‘
			function playAudio(base64Audio) {
				const audioSrc = `data:audio/webm;base64,${base64Audio}`;
				const audio = new Audio(audioSrc);
				audio.play().catch((e) => console.warn('æ’­æ”¾å¤±è´¥:', e));
			}
		</script>
	</body>
</html>
